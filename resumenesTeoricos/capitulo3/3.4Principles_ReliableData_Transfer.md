#  3.4 Principles of Reliable Data Transfer

##  El problema de fondo

* Internet no es perfecta: los paquetes pueden **perderse**, **retrasarse**, **duplicarse** o llegar en **desorden**.
* Pero muchas aplicaciones (ejemplo: descargar un archivo, mandar un mail, ver una página web) **necesitan que los datos lleguen completos y en el orden correcto**.

 Entonces surge la pregunta:
¿Cómo construimos un servicio confiable (Reliable Data Transfer, RDT) sobre un medio que es inherentemente poco confiable?

La respuesta: **añadiendo mecanismos de confiabilidad en la capa de transporte**.



##  Componentes básicos de RDT

1. **Confirmaciones (ACKs)**

   * El receptor le avisa al emisor: *“recibí bien tu paquete”*.
   * Ejemplo: como cuando mandás un WhatsApp y te aparecen los ✔✔.

2. **Retransmisiones (re-enviar datos)**

   * Si un paquete se pierde, el emisor lo vuelve a mandar.

3. **Temporizadores (timers)**

   * El emisor no puede esperar eternamente.
   * Si no recibe un ACK en un tiempo razonable → asume que se perdió y retransmite.

4. **Detección de errores**

   * Usando checksums para verificar si el paquete llegó corrupto.
   * Si está dañado, el receptor lo descarta o pide retransmisión.

5. **Números de secuencia**

   * Para identificar los paquetes y evitar duplicados.
   * Ejemplo: si te llega el mismo paquete dos veces, el número de secuencia ayuda a descartarlo.



##  Desarrollo paso a paso (casos de estudio en el libro)

### 1. **RDT 1.0** – Canal perfecto

* Suposición: no hay pérdidas ni errores.
* El emisor manda → el receptor recibe → listo.
* Poco realista, pero sirve como base.

---

### 2. **RDT 2.0** – Canal con errores (pero sin pérdidas)

* Ahora los paquetes pueden llegar corruptos.
* Se agregan:

  * **Checksums** para detectar errores.
  * **ACKs** (paquete llegó bien).
  * **NAKs** (paquete llegó mal).
* Si llega un NAK → el emisor retransmite.

Problema: si el ACK o NAK también se corrompe, puede haber confusión.

---

### 3. **RDT 2.1 y 2.2** – Mejor manejo de errores en ACK/NAK

* Se introducen **números de secuencia**.
* Con ellos, el receptor puede saber si un paquete es nuevo o una retransmisión.
* Se evita duplicar datos.

---

### 4. **RDT 3.0** – Canal con pérdidas y errores

* Ahora los paquetes pueden **no llegar nunca**.
* Solución: usar **temporizadores**.
* Si el emisor no recibe ACK después de cierto tiempo → retransmite el paquete.
* Este mecanismo es la base del **Stop-and-Wait Protocol**:

  * El emisor manda un paquete y espera el ACK antes de mandar el siguiente.



##  Problema del Stop-and-Wait

Aunque es confiable, tiene un **gran defecto**:

* Solo se transmite **un paquete a la vez**.
* Mientras el emisor espera el ACK, la red puede estar ociosa.

Ejemplo:
Si cada paquete tarda 100 ms en ir y volver, y ocupa solo 1 ms en enviarse → el 99% del tiempo la red está desperdiciada.

 Esto lleva a protocolos más avanzados (ventana deslizante, Go-Back-N, Selective Repeat) que veremos mas adelante.


##  Ejemplo 

Imaginá que le dictás tu número de DNI a alguien por teléfono:

* **Canal perfecto (RDT 1.0)**: lo anotan bien y no hay drama.
* **Con errores (RDT 2.0)**: si escuchan mal, te dicen *“¿me repetís?”*.
* **Con pérdidas (RDT 3.0)**: si no contestan en unos segundos, vos asumís que no escucharon y lo repetís.
* **Stop-and-Wait**: solo decís un número por vez y esperás confirmación antes de decir el siguiente.

---

La confiabilidad no es gratis.

* Lograr que los datos lleguen completos y ordenados requiere **mecanismos adicionales** (ACKs, timers, secuencias).
* Esto implica **más overhead y menos eficiencia**, pero es fundamental para aplicaciones donde la exactitud importa más que la velocidad.

---

