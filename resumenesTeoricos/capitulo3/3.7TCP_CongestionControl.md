#  3.7 TCP Congestion Control

##  Idea principal

TCP no solo garantiza **fiabilidad** (entrega ordenada, sin pérdidas) sino que también **controla la congestión**.
El objetivo: **usar la red eficientemente sin saturarla**.

TCP logra esto ajustando dinámicamente su **ventana de congestión (cwnd)**, que define cuántos bytes puede tener “en vuelo” sin ser confirmados.

 Piensalo como manejar en una autopista:

* Si la ruta está despejada, acelerás (TCP manda más paquetes).
* Si ves tráfico denso (pérdidas o retrasos), frenás (TCP reduce cwnd).



##  Señales de congestión para TCP

* **Pérdida de paquetes** → TCP interpreta que hubo congestión.

  * Puede detectarse por *timeout* (ACK no llega a tiempo).
  * O por recibir 3 ACK duplicados seguidos (triple duplicate ACK).
* **Retrasos crecientes** → también sugieren congestión.



##  Algoritmos de TCP para controlar congestión

### 1. **Slow Start (Arranque lento)**

* Al inicio, TCP **no sabe cuánto aguanta la red**.
* Comienza con cwnd = 1 MSS (Máximo Segmento).
* Por cada ACK recibido, cwnd se duplica → crecimiento **exponencial**.
* Esto sigue hasta:

  * Detectar una pérdida.
  * O llegar a un umbral llamado **ssthresh** (slow-start threshold).

Ejemplo:
cwnd = 1 → 2 → 4 → 8 → 16 MSS...
Hasta que algo frena.



### 2. **Congestion Avoidance (Evitación de congestión)**

* Cuando cwnd ≥ ssthresh, TCP entra en modo **crecimiento lineal**.
* Aumenta cwnd en 1 MSS cada RTT (más despacito).
* Así “testea” cuánto más puede mandar sin reventar la red.


### 3. **Detección de pérdida**

* **Timeout**: TCP interpreta mucha congestión.

  * Reduce cwnd a 1 MSS.
  * Reinicia slow start.
  * ssthresh se ajusta a la mitad del cwnd previo a la pérdida.

* **3 ACK duplicados** (más leve que timeout):

  * Activa **Fast Retransmit** → reenvía inmediatamente el paquete perdido.
  * Luego entra en **Fast Recovery**:

    * cwnd se reduce a la mitad.
    * Luego crece linealmente.



### 4. **AIMD: Additive Increase, Multiplicative Decrease**

Este es el corazón de TCP:

* **Increase Additive** → cwnd crece linealmente mientras no haya problemas.
* **Decrease Multiplicative** → cuando hay pérdida, cwnd se reduce a la mitad.

 Resultado: la típica curva “diente de sierra” de TCP.
Sube, sube, sube… ¡plaf! baja a la mitad, vuelve a subir…



##  Justicia en TCP

* Si dos conexiones TCP comparten un mismo enlace de capacidad C, en promedio cada una tenderá a usar C/2.
* Esto porque cada flujo sigue la misma lógica de AIMD.
* Por eso se dice que TCP es **fair (justo)**.

Si hay 3 usuarios en un enlace de 9 Mbps, cada uno terminará usando aprox 3 Mbps.



## Variantes de TCP

Con el tiempo surgieron mejoras para adaptarse a redes más rápidas y con más latencia:

* **TCP Reno** (clásico, usa fast retransmit/fast recovery).
* **TCP NewReno** (mejor manejo de múltiples pérdidas).
* **TCP CUBIC** (Linux, diseñado para altas velocidades).
* **TCP Vegas** (usa retrasos en vez de pérdidas como señal de congestión).



#  Resumen 

* TCP regula el tráfico con **cwnd**.
* Empieza con **slow start**, luego pasa a **congestion avoidance**.
* Maneja pérdidas con **timeout** o **3 ACK duplicados**.
* Sigue el principio **AIMD**: crecer lento, achicar fuerte.
* Es **justo** con otros flujos TCP.
* Variantes modernas buscan mejorar rendimiento en redes grandes.



 Pregunta clave de profe:

* **¿Por qué TCP interpreta la pérdida de paquetes como señal de congestión y no de error en el canal?**
   Porque en Internet la mayoría de las pérdidas se deben a **buffers llenos en routers** (congestión), no a errores físicos (que son muy poco frecuentes).


