# 5.1 Introducción (¿qué es el plano de control?)

La capa de red tiene dos “planos”:

* **Plano de datos**: mueve paquetes según una tabla de reenvío (forwarding table).
* **Plano de control**: *calcula, mantiene e instala* esas tablas (o “flow tables” si el equipo es SDN). En la práctica hay dos formas clásicas de organizarlo:
  **(a) Control por router (per-router):** cada router corre un algoritmo de enrutamiento y habla con sus vecinos para llenar *su* tabla. Así trabajan OSPF y BGP de toda la vida.&#x20;
  **(b) Control lógicamente centralizado (SDN):** un controlador (parece uno solo aunque por dentro sean varios) calcula y **distribuye** las tablas a los routers/switches; en cada equipo hay un “control agent” livianito que obedece. Este modelo permite programar funciones tipo firewall, NAT o balanceo con la abstracción *match-plus-action*. Hay despliegues reales a escala (p.ej., WANs internas de grandes proveedores).&#x20;

**Por ejemplo =)**

* *Per-router* es como cada colectivero decidiendo su mejor ruta hablando con otros choferes por handy.
* *SDN* es un centro de control de tránsito que ve todo el mapa y le va diciendo a cada chofer por dónde ir para evitar embotellamientos.

 El plano de control define **por dónde** van los paquetes. Puede estar **distribuido** (cada router decide) o **centralizado lógicamente** (un controlador decide y reparte). En ambos casos termina habiendo una secuencia concreta de routers que el paquete recorre.&#x20;


# 5.2 Algoritmos de Enrutamiento (¿cómo se calculan las rutas?)

Para razonar, modelamos la red como un **grafo**: nodos = routers; aristas = enlaces con un **costo** (longitud, capacidad, costo monetario, etc.). El objetivo típico es hallar **caminos de menor costo** entre origen y destino. Si todos los enlaces “valen” lo mismo, eso coincide con el “camino más corto”.&#x20;

## 5.2.A Clasificaciones útiles

1. **Centralizados vs. descentralizados**

* *Centralizado*: la “cabeza” tiene **mapa completo** (topología + costos) y calcula rutas (p. ej., un controlador SDN, o cada router corriendo LS con el mismo mapa). A estos se los asocia con **link-state (LS)**.&#x20;
* *Descentralizado*: cada router arranca sabiendo **sólo** el costo a sus vecinos y va mejorando sus estimaciones iterando con ellos. Esto es el **distance-vector (DV)**.&#x20;

2. **Estáticos vs. dinámicos**

* *Estático*: cambian raramente (intervención humana).
* *Dinámico*: se adaptan a cambios de carga/topología; más sensibles a problemas como bucles u oscilaciones.&#x20;

3. **Sensibles a carga vs. insensibles**

* *Load-sensitive*: el costo varía con congestión.
* *Hoy en Internet*: RIP/OSPF/BGP son **load-insensitive** (el costo no refleja la congestión en tiempo real).&#x20;

## 5.2.B Link-State (LS) + Dijkstra (Sección 5.2.1)

**Idea:** todos los routers obtienen el mismo **mapa completo** de la red mediante *broadcast* de “link-state packets” (qué vecinos tengo y con qué costo). Con ese mapa, **cada router** corre **Dijkstra** y calcula los caminos de menor costo hacia todos.&#x20;

* **Cómo funciona Dijkstra (a grandes rasgos):** es iterativo; mantiene un conjunto de nodos “ya resueltos” y va eligiendo siempre el siguiente con menor costo acumulado, actualizando vecinos. Al final, reconstruís la tabla de reenvío (siguiente salto por destino).&#x20;
* **Coste y mensajes:** LS implica que *cada nodo* conozca *cada enlace*: \~O(|N|·|E|) mensajes; cómputo típico O(|N|²) en la versión básica (sin estructuras de datos avanzadas).&#x20;

 pensá en *Waze* con el mapa completo (aunque sin congestión en vivo). Cada usuario calcula su ruta ideal con su copia del mapa.

## 5.2.C Distance-Vector (DV) (Sección 5.2.2)

**Idea:** cada router mantiene un **vector de distancias** estimadas a todos los destinos. Periódicamente (o ante cambios) **publica su vector a sus vecinos**. Al recibir el de un vecino *v*, actualiza su costo a “destino y” como:

> *costo a v + costo que v dice tener hasta y* (y se queda con el mínimo entre todos los vecinos).
> Este intercambio iterativo converge; cuando ya nadie mejora, se entra en **estado quiescente**.&#x20;

* **Intuición práctica:** es como enterarte de los precios para ir a distintos barrios preguntando a tus vecinos “¿cuánto te sale llegar a…?” y sumándole lo que te cuesta llegar *hasta ese vecino*.
* **Problemas clásicos:** puede **converger lento** y formar **bucles temporales**. El famoso **count-to-infinity** aparece cuando “las malas noticias” (un enlace que se rompió o encareció) tardan en propagarse; *poisoned reverse* ayuda, pero **no lo resuelve en general** (fallan los bucles de 3+ nodos). &#x20;
* **Protocolos reales tipo DV:** RIP y (con otro matiz) BGP se inspiran en DV.&#x20;

**Comparativa LS vs DV (alto nivel):**

* **Mensajería:** LS “inunda” estados de enlace (O(|N|·|E|)); DV charla **sólo** con vecinos pero puede tardar en converger.&#x20;
* **Convergencia y robustez:** LS suele converger rápido y aislar errores (cada uno calcula lo suyo con el mismo mapa). DV puede sufrir bucles y *count-to-infinity* si hay fallas o métricas cambiantes.&#x20;

**Ejemplo:** DV es el “boca a boca” de precios y caminos; LS es tener el mapa entero impreso y medido.



## Resumen 

* **5.1**: Dos estilos de control: **per-router** (cada router calcula) vs **SDN** (control **lógicamente centralizado** que reparte tablas). &#x20;
* **5.2**: Modelamos la red como grafo con **costos** y buscamos **rutas de menor costo**. Hay algoritmos **LS (Dijkstra)** con mapa global, y **DV** con intercambio iterativo entre vecinos; además clasificamos por **estático/dinámico** y **sensible/insensible a carga** (Internet usa mayormente insensible).  &#x20;


