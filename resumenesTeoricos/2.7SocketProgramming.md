
# 2.7 Socket Programming: Creating Network Applications

## ¿Qué es un socket?

* Es un **endpoint** (extremo) de comunicación.
* Lo abrís, le decís **familia** (IPv4/IPv6), **tipo** (TCP = flujo, UDP = datagrama) y **protocolo**.
* Con él podés:

  * **Cliente**: conectarte (`connect`) a `host:puerto`.
  * **Servidor**: **atender** conexiones (TCP) o **escuchar** datagramas (UDP) en un `bind(host, puerto)`.

### Parámetros típicos

* **Familia**: `AF_INET` (IPv4), `AF_INET6` (IPv6).
* **Tipo**: `SOCK_STREAM` (TCP), `SOCK_DGRAM` (UDP).

---

## 2.7.1 Socket Programming with UDP

### Características de UDP (datagramas)

* **Sin conexión**: no hay handshake; cada mensaje viaja “solo”.
* **No confiable**: puede perderse, duplicarse o llegar desordenado.
* **Mensaje con límites**: lo que enviás en `sendto` se recibe en **un** `recvfrom` (si entra en el buffer).
* **Rápido y liviano**: ideal para **voz/video en tiempo real**, juegos, telemetría, DNS, etc.
* **Tamaño**: cuidá el tamaño del datagrama (lo práctico es ≤ 1200–1400 bytes para evitar fragmentación).

### Flujo típico (servidor UDP)

1. `socket(AF_INET, SOCK_DGRAM)`
2. `bind(('0.0.0.0', PUERTO))` para escuchar.
3. Loop: `data, addr = recvfrom(...)` → procesás → `sendto(respuesta, addr)` (si corresponde).

### Flujo típico (cliente UDP)

1. `socket(AF_INET, SOCK_DGRAM)`
2. `sendto(payload, (host, puerto))`
3. Opcionalmente `recvfrom(...)` si esperás respuesta (echo, RPC simple, etc.).

### Ejemplo: Echo UDP (servidor)

```python
# udp_server.py
import socket

IP = "0.0.0.0"
PORT = 9999
BUF = 2048

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((IP, PORT))
print(f"UDP server escuchando en {IP}:{PORT}")

while True:
    data, addr = sock.recvfrom(BUF)         # bloqueante
    print(f"Rx {len(data)} bytes de {addr}")
    sock.sendto(data, addr)                 # eco
```

### Ejemplo: Echo UDP (cliente)

```python
# udp_client.py
import socket

SERVER = ("127.0.0.1", 9999)
msg = b"hola udp"

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2.0)                        # para no colgarse si no responde
sock.sendto(msg, SERVER)
data, addr = sock.recvfrom(2048)
print("Respuesta:", data.decode())
```

### Tips y gotchas en UDP

* **No hay garantía** de entrega → si te importa la confiabilidad, agregala vos: reintentos, números de secuencia, ACKs.
* **Orden**: puede cambiar → si importa, numerá mensajes y reordená.
* **Buffer**: si el datagrama es más grande que `recvfrom(BUF)`, se **trunca**.
* Podés “pseudo-conectarte” con `connect()` en UDP para **fijar** un destino y usar `send/recv` (sigue siendo UDP; solo simplifica la API y filtra paquetes de otros orígenes).

---

## 2.7.2 Socket Programming with TCP

### Características de TCP (flujo)

* **Conexión**: handshake 3 vías (SYN, SYN-ACK, ACK).
* **Confiable**: entrega sin pérdidas, sin duplicados y **en orden**.
* **Control de flujo y congestión**: ajusta el ritmo automáticamente.
* **Sin límites de mensaje**: es un **stream** de bytes. Vos definís **framing** (cómo separar mensajes).

### Flujo típico (servidor TCP)

1. `socket(AF_INET, SOCK_STREAM)`
2. `setsockopt(SO_REUSEADDR)` (recomendado)
3. `bind(('0.0.0.0', PUERTO))`
4. `listen(BACKLOG)` para ponerlo “a la escucha”
5. Loop: `conn, addr = accept()` (bloqueante) → manejar cada conexión (idealmente en un **hilo**, **proceso** o con **async**)

### Flujo típico (cliente TCP)

1. `socket(AF_INET, SOCK_STREAM)`
2. `connect((host, puerto))`
3. `sendall(...)` / `recv(...)`
4. `close()` (o `with` en Python)

### Framing (muy importante en TCP)

Como TCP es un **stream**, un `recv(1024)` puede traerte:

* Menos de un mensaje
* Exactamente un mensaje
* 1.5 mensajes (uno entero + parte del siguiente)

Soluciones típicas:

* **Delimitador** (p. ej. `\n`): protocolo “line-based”.
* **Prefijo de longitud** (4 bytes con `N` y luego `N` bytes de payload).
* **Mensajes de tamaño fijo** (siempre 256 bytes, p. ej.).

### Ejemplo: Echo TCP (servidor, línea por línea)

```python
# tcp_server.py
import socket
import threading

IP = "0.0.0.0"
PORT = 8888
BACKLOG = 100
BUF = 4096

def handle_client(conn, addr):
    print(f"Conectado: {addr}")
    with conn:
        # protocolo: líneas terminadas en \n
        partial = b""
        while True:
            chunk = conn.recv(BUF)
            if not chunk:
                break
            partial += chunk
            while b"\n" in partial:
                line, partial = partial.split(b"\n", 1)
                resp = line.upper() + b"\n"
                conn.sendall(resp)
    print(f"Cerrado: {addr}")

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind((IP, PORT))
sock.listen(BACKLOG)
print(f"TCP server escuchando en {IP}:{PORT}")

while True:
    conn, addr = sock.accept()
    threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()
```

### Ejemplo: Echo TCP (cliente)

```python
# tcp_client.py
import socket

SERVER = ("127.0.0.1", 8888)

with socket.create_connection(SERVER, timeout=3) as s:
    s.sendall(b"hola tcp\n")
    s.sendall(b"otra linea\n")
    print(s.recv(4096).decode(), end="")  # puede traer una o varias respuestas
    print(s.recv(4096).decode(), end="")
```

### Tips y gotchas en TCP

* Usá **`sendall`** (no `send`) para asegurar que salen **todos** los bytes.
* `recv(n)` puede devolver **menos** de `n` bytes; si necesitás exactamente `n`, **loop** hasta completar.
* **Timeouts**: `settimeout(seg)` para evitar bloqueos eternos.
* **SO\_REUSEADDR**: útil para reiniciar el servidor sin esperar TIME\_WAIT.
* **Concurrencia**:

  * simple: **hilos** por conexión
  * de alto rendimiento: **select/poll/epoll**, `selectors` o **asyncio**
* **Cierre ordenado**: cerrá la escritura con `shutdown(socket.SHUT_WR)` si querés decir “no mando más, pero sigo leyendo”.
* **Nagle & co.**: para latencias bajas en mensajes cortos, a veces se desactiva Nagle (`TCP_NODELAY`), pero no lo hagas a ciegas.
* **TLS**: si necesitás cifrado/autenticación, envolvé el socket TCP con `ssl` (Python) o usá librerías (OpenSSL, etc.).

---

## Cosas comunes a UDP/TCP 

* **Puertos**:

  * **Bien conocidos** (<1024, p. ej. 80 HTTP, 443 HTTPS).
  * **Registrados** (1024–49151).
  * **Efímeros** (49152–65535, los elige el SO para el cliente).
* **DNS**: resolvé `host` a IP con `getaddrinfo()` (soporta IPv6, etc.).
* **Interfaces**:

  * `127.0.0.1` = loopback (solo local).
  * `0.0.0.0` = todas las interfaces IPv4 (públicas/privadas) del host.
  * `::1` y `::` análogos en IPv6.
* **Firewalls/NAT**: pueden bloquear puertos o mapear direcciones; si “no conecta”, mirá ahí.
* **Tamaño de buffers**: ajustables con `setsockopt` (`SO_RCVBUF` / `SO_SNDBUF`).
* **Bloqueante vs no bloqueante**: `setblocking(False)` y `select()` / `selectors` / `asyncio` si vas a multiplexar I/O.

---

## ¿Cuándo elijo UDP vs TCP?

* **UDP** cuando: latencia mínima, tolerancia a pérdida, mensajes independientes y chicos (voz/video en vivo, juegos, DNS).
* **TCP** cuando: integridad y orden importan, querés simplificar confiabilidad (HTTP, mail, archivos, APIs “serias”).

---

## Mini-cheat sheet 

* UDP = **rápido**, **sin conexión**, **sin garantías**, **con límites de mensaje**.
* TCP = **conectado**, **confiable**, **ordenado**, **stream** (definís framing).
* Servidor TCP: `socket → bind → listen → accept → (send/recv)`.
* Servidor UDP: `socket → bind → (recvfrom/sendto)`.
* Cliente TCP: `socket → connect → sendall/recv`.
* Cliente UDP: `socket → sendto → recvfrom`.

---

