
##  2.2 The Web and HTTP

###  2.2.1 Overview of HTTP

* **HTTP (HyperText Transfer Protocol)** es el protocolo de la capa de aplicación que usan navegadores y servidores web para comunicarse.
* Funciona bajo el modelo **cliente-servidor**:

  * El navegador (cliente) hace requests (peticiones).
  * El servidor responde con respuestas que contienen los objetos (archivos HTML, imágenes, videos, etc.).
* La Web se basa en **páginas compuestas de objetos**. Un objeto puede ser un archivo HTML, imagen, sonido, etc.
* Una página web tiene un **archivo base HTML** que incluye referencias a otros objetos.
   Ejemplo: Entrás a un sitio, tu navegador pide el archivo HTML y después hace más requests para las imágenes, CSS, scripts, etc.

---

###  2.2.2 Non-Persistent and Persistent Connections

* **No persistente**:

  * Cada objeto requiere una nueva conexión TCP.
  * Ejemplo: si una página tiene 5 objetos, se abren 5 conexiones distintas.
  * Problema: mucho overhead, lentitud por el establecimiento repetido de conexiones TCP.
* **Persistente**:

  * Una sola conexión TCP puede transferir múltiples objetos.
  * El servidor mantiene la conexión abierta.
  * Puede ser con **pipelining** (el cliente manda varios requests seguidos sin esperar respuesta) → mejora la eficiencia.
* Hoy en día, **HTTP/1.1 y HTTP/2 usan conexiones persistentes** casi siempre.

---

###  2.2.3 HTTP Message Format

* Dos tipos principales de mensajes:

  * **Request** (del cliente → servidor):

    * Tiene: línea de petición (método, URL, versión), cabeceras (headers) y cuerpo (body, opcional).
    * Métodos comunes: **GET**, **POST**, **HEAD**, **PUT**, **DELETE**.
  * **Response** (del servidor → cliente):

    * Tiene: línea de estado (versión, código, razón), cabeceras y cuerpo con el contenido.
    * Ejemplo de códigos:

      * `200 OK` → todo bien.
      * `404 Not Found` → recurso no existe.
      * `301 Moved Permanently` → redirección.

---

###  2.2.4 User-Server Interaction: Cookies

* Problema: HTTP es **stateless** (sin memoria).
* Solución: **Cookies**, que permiten al servidor “recordar” al usuario.
* Funcionan así:

  * El servidor envía un identificador único en el header de respuesta.
  * El navegador guarda ese ID y lo reenvía en cada request posterior.
* Usos:

  * Mantener sesiones de usuario (ej: logueo en Gmail).
  * Guardar preferencias.
  * Seguimiento de usuarios para publicidad.

---

###  2.2.5 Web Caching

* **Cache Web (proxy caching)** → guarda copias locales de páginas para evitar pedirlas siempre al servidor original.
* Ventajas:

  * Reduce tiempos de respuesta para el usuario.
  * Reduce tráfico en la red.
  * Disminuye la carga en servidores.
* Ejemplo: Si vos y tu compañero visitan la misma página, la primera vez se baja del servidor original, pero después se sirve desde el proxy.
* Estrategias de control:

  * **Conditional GET**: el cache pregunta al servidor si el objeto cambió (si no, sigue usando la copia local).

---

###  2.2.6 HTTP/2

* Evolución de HTTP/1.1 para mejorar velocidad y eficiencia.
* Cambios clave:

  * **Multiplexing**: varios objetos pueden ir en paralelo dentro de la misma conexión TCP.
  * **Header compression**: reduce el peso de los headers.
  * **Server push**: el servidor puede mandar recursos antes de que el cliente los pida.
* Beneficios:

  * Menos latencia.
  * Mejor aprovechamiento de la conexión.
  * Mejor rendimiento en páginas modernas con muchos objetos.

---


* HTTP es el lenguaje entre navegadores y servidores.
* Pasamos de conexiones **no persistentes** a **persistentes** para mayor eficiencia.
* Los mensajes HTTP son **request** y **response**, con métodos y códigos claros.
* Las **cookies** permiten memoria en una web sin estado.
* El **caching** acelera la navegación y reduce tráfico.
* HTTP/2 trajo mejoras enormes con multiplexación, compresión y server push.

